<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Таймер сессии КПТ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .stage-progress {
            transition: width 1s linear;
        }
        .current-stage {
            box-shadow: 0 0 0 3px #3b82f6;
            background-color: #f0f9ff;
        }
        .hint-icon {
            transition: all 0.3s ease;
        }
        .hint-icon:hover {
            transform: scale(1.1);
            color: #3b82f6;
        }
        .hint-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }
        .hint-content.show {
            max-height: 300px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="app" class="container mx-auto px-4 py-8 max-w-4xl">
        <h1 class="text-3xl font-bold text-center mb-8 text-blue-800">Таймер сессии КПТ</h1>
        
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <div class="flex flex-col md:flex-row items-center justify-between gap-8">
                <!-- Timer Display -->
                <div class="flex flex-col items-center justify-center w-full md:w-1/3">
                    <div class="text-5xl font-bold text-blue-700 mb-4">{{ formatTime(currentTime) }}</div>
                    <div class="text-lg text-gray-600">из {{ formatTime(totalTime) }}</div>
                    <div class="mt-6 text-center">
                        <div class="text-xl font-semibold text-blue-800">{{ currentStageName }}</div>
                        <div class="text-gray-600">Осталось: {{ formatTime(remainingTimeInStage) }}</div>
                    </div>
                </div>
                
                <!-- Controls -->
                <div class="flex flex-col items-center w-full md:w-1/3 mt-6 md:mt-0">
                    <div class="flex space-x-4 mb-6">
                        <button @click="startTimer" :disabled="isRunning" 
                                class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-green-300 transition-colors flex items-center">
                            <i class="fas fa-play mr-2"></i>Старт
                        </button>
                        <button @click="pauseTimer" :disabled="!isRunning" 
                                class="px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 disabled:bg-yellow-300 transition-colors flex items-center">
                            <i class="fas fa-pause mr-2"></i>Пауза
                        </button>
                        <button @click="resetTimer" 
                                class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors flex items-center">
                            <i class="fas fa-redo mr-2"></i>Сброс
                        </button>
                    </div>
                    
                    <div class="w-full bg-gray-200 rounded-full h-4 mb-4">
                        <div class="bg-blue-600 h-4 rounded-full transition-all duration-1000" 
                             :style="{ width: progress + '%' }"></div>
                    </div>
                    <div class="text-sm text-gray-600">
                        Общий прогресс: {{ Math.round(progress) }}%
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Stages with Progress Bars -->
        <div class="bg-white rounded-xl shadow-lg p-6">
            <h2 class="text-xl font-semibold mb-4 text-blue-700">Этапы сессии:</h2>
            <div class="space-y-6">
                <div v-for="(stage, index) in stages" :key="index"
                     class="p-4 rounded-lg border border-gray-200 transition-all"
                     :class="{'current-stage': currentStageIndex === index}">
                    <div class="flex justify-between items-center mb-2">
                        <div class="font-medium flex items-center">
                            <span class="w-6 h-6 rounded-full bg-blue-100 text-blue-800 flex items-center justify-center mr-2 text-sm">{{ index + 1 }}</span>
                            {{ stage.name }}
                            <button @click="toggleHint(index)" class="ml-2 text-gray-400 hint-icon">
                                <i class="fas fa-question-circle"></i>
                            </button>
                        </div>
                        <div class="text-sm text-gray-600">
                            {{ formatTime(stage.duration) }}
                        </div>
                    </div>
                    
                    <!-- Hint Content -->
                    <div class="hint-content mt-2 bg-blue-50 p-3 rounded-lg" :class="{'show': stage.showHint}">
                        <div class="text-sm text-blue-800" v-html="stage.hint"></div>
                    </div>
                    
                    <div class="w-full bg-gray-200 rounded-full h-3 mt-3">
                        <div class="stage-progress h-3 rounded-full" 
                             :class="[currentStageIndex === index ? 'bg-blue-600' : (index < currentStageIndex ? 'bg-green-500' : 'bg-gray-300')]"
                             :style="{ width: stageProgress(index) + '%' }"></div>
                    </div>
                    <div class="text-xs text-gray-500 mt-1 text-right">
                        {{ stageProgressText(index) }}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, watch, onUnmounted } = Vue;
        
        createApp({
            setup() {
                // Состояние таймера
                const totalTime = ref(3000); // 50 минут в секундах
                const currentTime = ref(0);
                const isRunning = ref(false);
                const timer = ref(null);
                
                // Этапы сессии КПТ с подсказками
                const stages = ref([
                    { 
                        name: 'Проверка настроения/медикаментов', 
                        duration: 300, 
                        color: 'bg-blue-200',
                        hint: 'Используйте шкалы самооценки (например, Шкалу депрессии Бека) для оценки текущего состояния клиента. Уточните, принимает ли клиент назначенные медикаменты и нет ли побочных эффектов. Отслеживание динамики помогает оценить прогресс и при необходимости скорректировать лечение.',
                        showHint: false
                    },
                    { 
                        name: 'Составление повестки', 
                        duration: 300, 
                        color: 'bg-blue-300',
                        hint: 'Совместно с клиентом определите приоритетные темы для обсуждения. Повестка должна быть конкретной и реалистичной. Учитывайте как текущие проблемы, так и долгосрочные цели терапии. Это повышает эффективность сессии и вовлеченность клиента.',
                        showHint: false
                    },
                    { 
                        name: 'Обзор плана действий', 
                        duration: 300, 
                        color: 'bg-blue-400',
                        hint: 'Обсудите выполнение домашнего задания, выявите успехи и трудности. Если задание не выполнено, исследуйте причины вместе с клиентом без осуждения. Это помогает понять препятствия и адаптировать будущие задания для повышения вероятности их выполнения.',
                        showHint: false
                    },
                    { 
                        name: 'Обсуждение повестки', 
                        duration: 1200, 
                        color: 'bg-green-400',
                        hint: 'Основная часть сессии. Используйте когнитивные техники для выявления и оценки автоматических мыслей, поведенческие эксперименты и решение проблем. Сосредоточьтесь на 1-2 ключевых темах, чтобы проработать их глубоко, а не поверхностно касаться многих вопросов.',
                        showHint: false
                    },
                    { 
                        name: 'Промежуточные итоги', 
                        duration: 300, 
                        color: 'bg-green-500',
                        hint: 'Кратко резюмируйте ключевые моменты обсуждения. Убедитесь, что клиент понимает основные выводы и связь между мыслями, эмоциями и поведением. Это укрепляет learning и помогает клиенту интегрировать новые perspectives.',
                        showHint: false
                    },
                    { 
                        name: 'Финальные итоги', 
                        duration: 240, 
                        color: 'bg-orange-400',
                        hint: 'Подведите итоги всей сессии, выделите наиболее важные insights. Попросите клиента сформулировать основные выводы своими словами - это повышает усвоение материала. Убедитесь, что клиент четко понимает, что он вынес из сессии.',
                        showHint: false
                    },
                    { 
                        name: 'Новый план действий', 
                        duration: 240, 
                        color: 'bg-orange-500',
                        hint: 'Совместно разработайте конкретные, измеримые и реалистичные задания на следующую неделю. Учитывайте потенциальные препятствия и разработайте стратегии их преодоления. Задание должно быть связано с целями терапии и практическим применением навыков, полученных на сессии.',
                        showHint: false
                    },
                    { 
                        name: 'Обратная связь', 
                        duration: 120, 
                        color: 'bg-orange-600',
                        hint: 'Запросите feedback о сессии - что было полезным, что можно улучшить. Это укрепляет терапевтический альянс и позволяет адаптировать терапию под потребности клиента. Проявите genuine интерес к мнению клиента и будьте открыты к конструктивной критике.',
                        showHint: false
                    }
                ]);
                
                // Вычисляемые свойства
                const progress = computed(() => (currentTime.value / totalTime.value) * 100);
                
                const currentStageIndex = computed(() => {
                    let elapsed = currentTime.value;
                    let total = 0;
                    for (let i = 0; i < stages.value.length; i++) {
                        total += stages.value[i].duration;
                        if (elapsed < total) {
                            return i;
                        }
                    }
                    return stages.value.length - 1;
                });
                
                const currentStageName = computed(() => {
                    return stages.value[currentStageIndex.value]?.name || 'Завершено';
                });
                
                const remainingTimeInStage = computed(() => {
                    let elapsed = currentTime.value;
                    let stageStart = 0;
                    
                    for (let i = 0; i < currentStageIndex.value; i++) {
                        stageStart += stages.value[i].duration;
                    }
                    
                    const stageDuration = stages.value[currentStageIndex.value]?.duration || 0;
                    const timeInStage = elapsed - stageStart;
                    return Math.max(0, stageDuration - timeInStage);
                });
                
                // Методы
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                };
                
                const startTimer = () => {
                    if (currentTime.value >= totalTime.value) {
                        resetTimer();
                    }
                    
                    isRunning.value = true;
                    timer.value = setInterval(() => {
                        currentTime.value += 1;
                        
                        if (currentTime.value >= totalTime.value) {
                            pauseTimer();
                            currentTime.value = totalTime.value;
                        }
                    }, 1000);
                };
                
                const pauseTimer = () => {
                    isRunning.value = false;
                    clearInterval(timer.value);
                };
                
                const resetTimer = () => {
                    pauseTimer();
                    currentTime.value = 0;
                    // Скрыть все подсказки при сбросе
                    stages.value.forEach(stage => {
                        stage.showHint = false;
                    });
                };
                
                const stageProgress = (index) => {
                    let stageStartTime = 0;
                    for (let i = 0; i < index; i++) {
                        stageStartTime += stages.value[i].duration;
                    }
                    
                    const stageDuration = stages.value[index].duration;
                    
                    if (index < currentStageIndex.value) {
                        return 100; // Этап завершен
                    } else if (index > currentStageIndex.value) {
                        return 0; // Этап еще не начался
                    } else {
                        // Текущий этап
                        const timeInStage = currentTime.value - stageStartTime;
                        return Math.min(100, (timeInStage / stageDuration) * 100);
                    }
                };
                
                const stageProgressText = (index) => {
                    if (index < currentStageIndex.value) {
                        return 'Завершено';
                    } else if (index > currentStageIndex.value) {
                        return 'Ожидание';
                    } else {
                        return `Выполнено: ${Math.round(stageProgress(index))}%`;
                    }
                };
                
                const toggleHint = (index) => {
                    stages.value[index].showHint = !stages.value[index].showHint;
                };
                
                // Автоматическая очистка таймера при уничтожении компонента
                onUnmounted(() => {
                    clearInterval(timer.value);
                });
                
                return {
                    totalTime,
                    currentTime,
                    isRunning,
                    stages,
                    currentStageIndex,
                    currentStageName,
                    remainingTimeInStage,
                    progress,
                    formatTime,
                    startTimer,
                    pauseTimer,
                    resetTimer,
                    stageProgress,
                    stageProgressText,
                    toggleHint
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
